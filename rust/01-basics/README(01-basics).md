# Rust Basics

Rust의 핵심 개념(소유권, 빌림, 라이프타임)을 빠르고 깊게 익히기 위한 기초 트랙입니다. 각 주제는 30~90분 내 실습을 목표로 하며, 실행/테스트 결과와 배운 점을 간단히 기록합니다.

## Rust 배경과 목표
- 탄생 배경: 2006~2010년 모질라 내부에서 시작되어 2015년 1.0 출시. C/C++ 계열 시스템 프로그래밍의 메모리 안전 문제(버퍼 오버런, use-after-free)를 언어 차원에서 해결하기 위해 설계되었습니다.
  - 문제 예시
    - 버퍼 오버런: 배열/버퍼 크기보다 많이 쓰거나 읽어 다른 메모리를 덮어쓰는 오류.
    - use-after-free: 이미 해제한 포인터를 다시 써서 크래시/보안 취약점이 생기는 상황.
    - 데이터 레이스: 여러 스레드가 동시에 같은 메모리를 쓰거나 읽으며 순서가 뒤엉켜 잘못된 결과가 나는 문제.
  - Rust의 언어 차원 해결책
    - 소유권(ownership)과 빌림(borrow) 규칙으로 “누가 언제 메모리를 쓸 수 있는지”를 컴파일 타임에 강제.
    - 불변/가변 참조 규칙: 동시에 여러 가변 참조를 금지해 데이터 레이스를 차단(`&T`는 여러 개 가능, `&mut T`는 단 하나만).
    - 라이프타임 검사: 참조가 가리키는 값보다 오래 살지 못하도록 컴파일러가 검증해 use-after-free를 방지.
      - 함수 시그니처나 구조체에 라이프타임을 표기하면, 참조의 “유효 기간” 관계를 명시해 컴파일러가 체크한다.
      - dangling 포인터(이미 사라진 값을 가리키는 포인터)를 컴파일 단계에서 차단한다.
    - 초기화 전 사용 금지 + Null 대체
      - 변수를 쓸 때 반드시 초기화해야 하며, 초기화되지 않은 메모리를 읽는 UB를 원천 차단한다.
        - UB(Undefined Behavior): 언어가 결과를 보장하지 않아 예측 불가한 동작이 발생하는 상태. C/C++에선 미초기화 메모리 읽기, 잘못된 포인터 연산 등이 대표적이다.
      - 널 포인터 대신 `Option<T>`로 “값이 없을 수 있음”을 타입으로 표현해 런타임 NPE를 줄인다.
        - NPE(Null Pointer Exception): 값이 없는데 있는 것처럼 접근해 런타임 크래시가 나는 오류. Rust는 널 대신 `Option`으로 “없음”을 타입 수준에서 표현해 컴파일 때부터 체크한다.
- 핵심 목표
  - 메모리 안전성과 데이터 레이스 없는 동시성(safe concurrency)을 컴파일 타임에 보장
    - 소유권/빌림/라이프타임, Send/Sync 트레잇 자동 검증으로 “동시에 같은 데이터를 잘못 다루는” 경우를 컴파일러가 거른다.
  - 성능은 C/C++ 수준을 유지(제로 코스트 추상화)
    - 이터레이터, Result, Option 같은 고수준 문법을 써도 필요 없는 런타임 오버헤드가 없도록 설계됐다.
  - 현대적 도구 체인(cargo, crates.io)과 친화적인 패키지/빌드/테스트 경험 제공
    - cargo로 빌드/테스트/포맷/린트를 일괄 처리하고, crates.io를 통해 의존성을 선언만으로 받아 쓸 수 있다.
  - 낮은 런타임 오버헤드(가비지 컬렉션 부재)로 임베디드부터 서버까지 폭넓은 적용
    - GC를 두지 않아 예측 가능한 성능/지연(latency)을 요구하는 시스템(임베디드, 게임, 서버)에서 사용하기 용이하다.

## 추천 학습 순서 (numbering)
0) 툴체인 체크 & 헬로월드 실행
1) Cargo 패키지 구조로 헬로월드 실행
2) 기본 문법(불변/가변, shadowing, if/loop/for, match)
3) 환경 준비 및 툴체인 확인
4) 소유권/이동/복사/슬라이스와 borrow checker 체험
5) 참조와 라이프타임 표기, 함수/구조체 시그니처 설계
6) `enum` + `match`, `Result`/`Option` 패턴으로 제어 흐름 익히기
7) 컬렉션(`Vec`, `String`, `HashMap`)과 이터레이터 체이닝으로 데이터 처리
8) 에러 처리: `?`, 에러 래핑, `thiserror`로 커스텀 에러 정의
9) 모듈/크레이트 구조, `pub` 가시성, 워크스페이스 감각
10) 동시성 기초: `std::thread`, `JoinHandle`, `Send/Sync` 개념
11) (선택) `async/.await` 기초로 확장

주제마다 작은 예제를 만들고, 끝날 때마다 실행 결과와 회고를 기록하세요.

## 환경 준비
- 설치
  - 스크립트: `curl --proto '=https' --tlsv1.2 -sSf https://sh.rustup.rs | sh`
    - `rustup` 설치 스크립트로 stable 툴체인, `cargo`, `rustc`가 기본 설치됩니다.
    - 설치 중 프로파일은 기본(default) 선택을 권장합니다(필요 시 minimal 선택 가능).
    - PATH 반영 안내가 나오면 터미널을 재시작하거나 안내된 명령을 실행해 PATH를 갱신하세요.
    - 제거가 필요하면 `rustup self uninstall`로 정리할 수 있습니다.
  - 기본 toolchain 확인: `rustc --version`, `cargo --version`
    - 설치/업데이트가 정상 적용됐는지 버전을 확인합니다.
    - 협업 시 버전 차이로 인한 빌드 편차를 줄이기 위해 기록해 두면 좋습니다.
  - 최신 안정화 업데이트: `rustup update stable`
    - stable 채널을 최신으로 맞춰 예제/도구가 동일 환경에서 동작하도록 합니다.
    - 새 lint/언어 기능이 필요하거나 보안 패치가 있을 때 반드시 실행하세요.
- 포맷/린트
 - 포맷: `cargo fmt`
   - rustfmt로 전체 워크스페이스를 일관된 스타일로 자동 정렬합니다.
   - `.rustfmt.toml`를 두면 팀 규칙을 커스터마이즈할 수 있습니다.
   - 커밋 전 자동 포맷을 위해 pre-commit 훅이나 CI에서 실행하는 것을 권장합니다.
 - 린트: `cargo clippy -- -D warnings`
   - clippy의 권장·pedantic 룰을 적용해 잠재 버그/냄새를 잡습니다.
   - `-D warnings`로 모든 경고를 컴파일 오류로 승격해 CI에서 놓치지 않도록 합니다.
   - 특정 린트를 무시해야 하면 해당 구문에 `#[allow(clippy::<lint_name>)]`를 한정적으로 사용하세요. 무분별한 전역 allow는 지양합니다.
- 실행/테스트
  - 바이너리 실행: `cargo run -p <패키지>` 또는 단일 파일 `rustc file.rs && ./file`
    - 워크스페이스에서 특정 바이너리 패키지를 실행할 때 `-p`를 사용합니다.
    - 단일 파일 실습은 빠르게 컴파일/실행하기 위해 `rustc file.rs && ./file`로 테스트할 수 있습니다.
  - 테스트: `cargo test`
    - 기본은 유닛 테스트, `cargo test -- --ignored`로 무시된 테스트 실행.
    - `cargo test --package <pkg> --test <file>`로 특정 패키지/통합 테스트만 실행 가능.
- rustc 방식 vs cargo 방식
  - `rustc file.rs`: 단일 파일을 바로 컴파일해 빠르게 결과를 확인. 의존성/패키지 관리 없음, 실습·실험에 적합.
  - `cargo run`/`cargo build`: Cargo.toml을 기준으로 패키지·의존성·빌드 프로필(debug/release)을 관리. 재현성, 멀티 파일/모듈, 외부 크레이트 사용에 적합.
  - 학습 초반에는 `rustc`로 빠른 피드백을 얻고, 구조가 커지거나 의존성이 필요하면 `cargo`로 전환하세요.
- 문서
  - 표준 라이브러리 로컬 문서: `rustup doc --std`
    - 오프라인에서도 std 문서를 탐색할 수 있어 빠른 레퍼런스로 유용합니다.
  - 크레이트 문서 빌드: `cargo doc --open`
    - 프로젝트의 public API 문서를 로컬로 빌드/브라우징하여 공개 범위와 타입 정보를 검증합니다.

## 학습 흐름 체크리스트
- 소유권/이동/복사/슬라이스, `borrow checker` 동작 이해
- 참조와 라이프타임 표기, 함수 인자/반환 시 라이프타임 설계
- `enum` + `match`, `Result`/`Option` 패턴
- 컬렉션: `Vec`, `String`, `HashMap`; 이터레이터 어댑터( `map`, `filter`, `collect` )
- 에러 처리: `?` 연산자, 에러 래핑, `thiserror`로 커스텀 에러
- 모듈/크레이트 구조, `pub` 가시성, `cargo` 워크스페이스 감각
- 동시성 기초: `std::thread`, `JoinHandle`, `Send/Sync`; 이후 `async/.await`로 확장

## 추천 실습 세트
- `00-hello-world/`: rustc로 단일 파일 컴파일/실행, 최소 바이너리와 println! 매크로 사용
- `01-cargo-hello/`: Cargo.toml + src/main.rs 구조로 빌드/실행 경험
- `02-basic-syntax/`: 불변/가변, shadowing, if/loop/for, match 기본 제어 흐름
- `lifetimes_fn.rs`: 함수/구조체에서 라이프타임 주석 적용
- `match_result.rs`: `Result` 처리와 에러 래핑, `?` 연산자
- `iter_playground.rs`: 이터레이터 체이닝, 소유권/빌림이 섞일 때의 수집 패턴
- `concurrency_threads.rs`: 스레드 생성/조인, move 클로저, 데이터 공유 시 소유권 패턴
- `zz-ownership-intro/`: (선택) 소유권 이동/복사/빌림 기본, 함수 인자 전달 패턴

## 기록 템플릿 (실습 후 README에 추가)
- 파일/주제:
- 실행/테스트: 명령어와 주요 출력
- 배운 점:
- 막힌 점/해결:
- 다음 할 일:
